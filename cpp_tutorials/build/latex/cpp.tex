% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{cpp Documentation}
\date{December 19, 2016}
\release{1.0.1}
\author{abhishekcs10}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Input}
\label{input:welcome-c}\label{input::doc}\label{input:input}

\section{input number to arbitrary precision}
\label{input:input-number-to-arbitrary-precision}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}math.h\PYGZgt{}

float val = 37.777779;

float rounded\PYGZus{}down = floorf(val * 100) / 100;   /* Result: 37.77 */
float nearest = roundf(val * 100) / 100;  /* Result: 37.78 */
float rounded\PYGZus{}up = ceilf(val * 100) / 100;      /* Result: 37.78 */
\end{Verbatim}

Notice that there are three different rounding rules you might want to choose: round down (ie, truncate after two decimal places), rounded to nearest, and round up. Usually, you want round to nearest.

As several others have pointed out, due to the quirks of floating point representation, these rounded values may not be exactly the ``obvious'' decimal values, but they will be very very close.

Above code prints double number upto n precision


\section{roundf-\textgreater{}}
\label{input:roundf}\begin{quote}

round double number to nearest integer. Thus to get nearest integer precision do-\textgreater{}
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
number=(number*(10\PYGZca{}p))/(10\PYGZca{}p); //number is rounder for p precision
\end{Verbatim}


\chapter{Output}
\label{output:output}\label{output::doc}

\section{print to arbitrary precision}
\label{output:print-to-arbitrary-precision}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}.*lf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{double}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Above code prints double number upto n precision


\chapter{Date format}
\label{dateformat::doc}\label{dateformat:date-format}

\section{Determine day on given date}
\label{dateformat:determine-day-on-given-date}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include\PYGZlt{}stdio.h\PYGZgt{}

int dayofweek(int d, int m, int y)
\PYGZob{}
        static int t[] = \PYGZob{} 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 \PYGZcb{};
        y \PYGZhy{}= m \PYGZlt{} 3;
        return ( y + y/4 \PYGZhy{} y/100 + y/400 + t[m\PYGZhy{}1] + d) \PYGZpc{} 7;
\PYGZcb{}

/* Driver function to test above function*/
int main()
\PYGZob{}
        int day = dayofweek(30, 8, 2010);
        printf (\PYGZdq{}\PYGZpc{}d\PYGZdq{}, day);
        return 0;
\PYGZcb{}
\end{Verbatim}


\section{Explanation of above}
\label{dateformat:explanation-of-above}
Let us start with the simple scenario in which leap years did not exist and every year had 365 days.

Knowing  what day January 1 falls on a certain year, it is easy to find which  day any other date falls. This is how you go about it : January has 31 =  7 × 4 + 3 days, so February 1 will fall on the day which follows three  days after January 1. Similarly, March 1 will fall on the day three days  after the day corresponding to January 1, April 1 will fall 6 days  after, and so on. Thus, the first days of each month are offset with  respect to January 1 by the array \{0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5\}.  This array is essentially what t{[}{]} is. Notice that it is slightly  different from the t{[}{]} given in the question, but that is due to leap  years and will be explained later. Once the day corresponding to the  first date of the month is known, finding the day for any other date is  just a matter of addition.

Since  365 = 7 × 52 + 1, the day corresponding to a given date will become  incremented by 1 every year. For example, July 14, 2014 is a Monday and  July 14, 2015 will be a Tuesday. Hence adding the difference between  year numbers allows us to switch from the day of a reference year to any  other year.

At this stage, the leap-year free dow function can be written as such:

\begin{Verbatim}[commandchars=\\\{\}]
int dow(int y, int m, int d)\PYGZob{}
  static int t[] = \PYGZob{}0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5\PYGZcb{};
  return (y + t[m\PYGZhy{}1] + d + c) \PYGZpc{} 7;
\PYGZcb{}
\end{Verbatim}

Here  c is a constant which corresponds to setting the ``origin'' of the day  system : y, t{[}m{]} and d only tell us how many days to shift by; we need a  reference to start the shifting and which is provided by c.

Now  let us look at the real case when there are leap years. Every 4 years,  our calculation will gain one extra day. Except every 100 years when it  doesn't. Except every 400 years when it does (Seriously, what kind of  intelligent designer comes up with this stuff? Couldn't the duration of  the year have been an integer multiple of the synodic day?). How do we  put in these additional days? Well, just add y/4 - y/100 + y/400. Note  that all division is integer division. This adds exactly the required  number of leap days.

Except  there is a tiny problem. The leap day is not January 0, it is February  29. This means that the current year should not be counted for the leap  day calculation for the first two months.

How  do we do this? Well, there are probably many intuitive ways to go about  this. But this piece of code sacrifices intuition for brevity. Suppose  that if the month were January or February, we subtracted 1 from the  year. This means that during these months, the y/4 value would be that  of the previous year and would not be counted.

Smart,  right? Except for a tiny problem. We are subtracting 1 from the year  for January and February for non-leap years too. This means that there  would be a ``blank'' day between February 28 and March 1, that is, we have  made every non-leap year a leap year, and leap years double-leap years.  Hm, so what if we subtracted 1 from the t{[}{]} values of every month after  February? That would fill the gap, and the leap year problem is solved.  That is, we need to make the following changes:

\begin{Verbatim}[commandchars=\\\{\}]
t[] now becomes \PYGZob{}0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4\PYGZcb{}
\end{Verbatim}

if m corresponds to Jan/Feb (that is, m\textless{}3) we decrement y by 1
the annual increment inside the modulus is now y + y/4 - y/100 + y/400 in place of y

That's it, we get the full solution

\begin{Verbatim}[commandchars=\\\{\}]
int dow(int y, int m, int d)\PYGZob{}
  static int t[] = \PYGZob{}0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4\PYGZcb{};
  y \PYGZhy{}= m \PYGZlt{} 3;
  return (y + y/4 \PYGZhy{} y/100 + y/400 + t[m\PYGZhy{}1] + d + c) \PYGZpc{} 7;
\PYGZcb{}
\end{Verbatim}

Coincidentially, c just happens to be 0 - this is an empirical fact and cannot be ``derived'' from anything we have done till now - and we get back the function in the question.


\chapter{Allocation in c}
\label{allocation:allocation-in-c}\label{allocation::doc}
applies to pointer of data structure


\section{malloc}
\label{allocation:malloc}
\begin{Verbatim}[commandchars=\\\{\}]
(void *) malloc (num*sizeof(arr));
\end{Verbatim}

simply allocates memory


\section{calloc}
\label{allocation:calloc}
\begin{Verbatim}[commandchars=\\\{\}]
(void *) calloc(int num, sizeof(type));
\end{Verbatim}

clears memory and initializes to zero.


\section{c++ allocation}
\label{allocation:c-allocation}
\begin{Verbatim}[commandchars=\\\{\}]
pointer = new type
pointer = new type [number\PYGZus{}of\PYGZus{}elements]
\end{Verbatim}

The first expression is used to allocate memory to contain one single element of type type. The second one is used to allocate a block (an array) of elements of type type, where number\_of\_elements is an integer value representing the amount of these. For example:

\begin{Verbatim}[commandchars=\\\{\}]
int* foo;
foo = new int [5];
\end{Verbatim}

In this case, the system dynamically allocates space for five elements of type int and returns a pointer to the first element of the sequence, which is assigned to foo (a pointer). Therefore, foo now points to a valid block of memory with space for five elements of type int.

\begin{Verbatim}[commandchars=\\\{\}]
int *k;
k=new (nothrow) int[i];
\end{Verbatim}

In this case, if the allocation of this block of memory fails, the failure can be detected by checking if foo is a null pointer:

\begin{Verbatim}[commandchars=\\\{\}]
1 int* foo;
2 foo = new (nothrow) int [5];
3 if (foo == nullptr) \PYGZob{}
4 // error assigning memory. Take measures.
5 \PYGZcb{}
\end{Verbatim}


\chapter{algorithm}
\label{algorithm::doc}\label{algorithm:algorithm}

\section{sorting}
\label{algorithm:sorting}

\subsection{constructors}
\label{algorithm:constructors}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sort}\PYG{p}{(}\PYG{n}{begin\PYGZus{}iterator}\PYG{p}{,} \PYG{n}{end\PYGZus{}iterator}\PYG{p}{)}
\PYG{n}{sort}\PYG{p}{(}\PYG{n}{begin}\PYG{p}{,}\PYG{n}{end}\PYG{p}{,}\PYG{n+nb}{cmp}\PYG{p}{)}
\end{Verbatim}

where cmp is any function that defines what comparison makes the first arguement of the function smaller than the other.

eg:
\begin{description}
\item[{::}] \leavevmode\begin{description}
\item[{cmp(a,b)\{}] \leavevmode\begin{description}
\item[{if(a\textless{}b)}] \leavevmode
return true;

\item[{else}] \leavevmode
return false;

\end{description}

\end{description}

\end{description}


\chapter{VECTOR}
\label{vector:vector}\label{vector::doc}

\section{unique(begin,end)}
\label{vector:unique-begin-end}
returns iterator of last element inserted and does not alters the size of container


\section{resize(count)}
\label{vector:resize-count}\begin{description}
\item[{::}] \leavevmode
resize(end-begin)

\end{description}

where end denotes the last index of resized array and begin represents the starting index of resized array.


\section{assign(int how\_many, int what\_value)}
\label{vector:assign-int-how-many-int-what-value}
assigns new values to vector array

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{arr}\PYG{o}{.}\PYG{n}{assign}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{Verbatim}

assigns n elements initialized with 100

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{arr} \PYG{p}{(}\PYG{n}{c\PYGZus{}arr}\PYG{p}{,}\PYG{n}{c\PYGZus{}arr}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}
\end{Verbatim}

assigns value from c\_array to vector


\chapter{Stack}
\label{stack::doc}\label{stack:stack}

\section{Constructor}
\label{stack:constructor}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}} \PYG{n}{var}\PYG{p}{;}
\end{Verbatim}


\section{insert}
\label{stack:insert}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{Verbatim}


\section{access-top}
\label{stack:access-top}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

return top element


\section{pop top}
\label{stack:pop-top}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

deletes top element and return nothing


\chapter{Queue}
\label{queue:queue}\label{queue::doc}

\section{Constructor}
\label{queue:constructor}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{queue}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}} \PYG{n}{var}\PYG{p}{;}
\end{Verbatim}


\section{insert -rear}
\label{queue:insert-rear}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}


\section{delete -front}
\label{queue:delete-front}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{access front element //the first inserted element}
\label{queue:access-front-element-the-first-inserted-element}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

return the front element


\section{check if queue is empty}
\label{queue:check-if-queue-is-empty}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

returns true if empty


\section{access rear element //newest inserted}
\label{queue:access-rear-element-newest-inserted}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Priority Queue(MAX)}
\label{priority_queue::doc}\label{priority_queue:priority-queue-max}

\section{Constructor}
\label{priority_queue:constructor}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}} \PYG{n}{var}\PYG{p}{;}
\end{Verbatim}


\section{Insertion}
\label{priority_queue:insertion}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Deletion}
\label{priority_queue:deletion}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

returns nothing


\section{Access top element}
\label{priority_queue:access-top-element}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{o}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

returns the max element


\chapter{MAP}
\label{map:map}\label{map::doc}

\section{Create map}
\label{map:create-map}
map\textless{}key\_type, value\_type\textgreater{} arr;


\section{Insert}
\label{map:insert}
arr{[}key{]}=value;//inserts if key doesnot exist and replaces value if exists


\section{iterator}
\label{map:iterator}
map\textless{} , \textgreater{}::iterator it;


\section{find key}
\label{map:find-key}
arr.find(key);

returns iterator and if iterator ==arr.end() it is not present in map


\section{access value using iterator}
\label{map:access-value-using-iterator}
it-\textgreater{}first gives key

it-\textgreater{}second gives value


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
